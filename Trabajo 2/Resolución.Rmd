---
title: "Selección de Catering para Eventos Universitarios: Enfoque de Decisión Multicriterio"
author: "Daniel Limón"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output:
  pdf_document:
    toc: true
    number_sections: true
  html_document:
    toc: true
    number_sections: true
    df_print: paged
fontsize: 11pt
lang: es
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Introducción

La selección de un servicio de catering para eventos universitarios implica equilibrar múltiples criterios que, a menudo, entran en conflicto: **coste**, **calidad percibida**, **capacidad para atender dietas** y **fiabilidad logística**. En este trabajo abordamos el problema mediante técnicas de **Decisión Multicriterio (MCDM)**, que permiten estructurar la toma de decisiones, ponderar prioridades y sintetizar información heterogénea de forma transparente y reproducible.

En particular, el problema considera **seis alternativas** de catering y **cuatro criterios** con **subcriterios** cuantitativos (p. ej., precio por persona, tiempos de respuesta, incidencias) y cualitativos codificados en escalas discretas (p. ej., sabor, presentación, variedad de dietas). Este diseño facilita aplicar métodos MCDM ampliamente utilizados tanto en la literatura académica como en la práctica profesional.


# Objetivos

**Objetivo general**

Priorizar y seleccionar la mejor alternativa de catering para eventos universitarios aplicando técnicas de **Decisión Multicriterio** con datos estructurados y criterios explícitos.

**Objetivos específicos**

1. **Estructurar** el problema en una jerarquía de criterios y subcriterios, identificando claramente qué métricas se **maximizan** y cuáles se **minimizan**.
2. **Aplicar AHP** para obtener pesos de criterios y subcriterios, verificando la **consistencia** (CR < 0,10) y derivando un ranking inicial.
3. **Aplicar ELECTRE I**, definiendo umbrales de **indiferencia (q)**, **preferencia (p)** y **veto**, para construir la relación de sobreclasificación y el **núcleo** de alternativas.
4. **Aplicar PROMETHEE II**, especificando funciones de preferencia y parámetros (q/p), para calcular **flujos** positivos, negativos y **netos** y obtener un **ranking completo**.
5. **Realizar análisis de sensibilidad** sobre pesos y parámetros (q/p) para evaluar la **robustez** del ranking y reconocer escenarios en los que cambie la decisión.
6. **Comparar** los resultados de AHP, ELECTRE y PROMETHEE, **explicando** las diferencias derivadas de la modelización (p. ej., efecto del veto o de las funciones de preferencia) y formulando **recomendaciones**.
7. **Comunicar** los hallazgos con **gráficos** (barras de pesos, heatmap de desempeño, grafo ELECTRE, flujos PROMETHEE) y una **discusión** clara que justifique la alternativa seleccionada.

**Datos:** Se empleará el fichero `data/datos_catering.csv` con las seis alternativas y los subcriterios cuantificados. En secciones posteriores se documentan los preprocesos y las decisiones de normalización.

# Datos y procesado

En esta sección se describe la estructura de los datos, se realizan comprobaciones básicas de calidad y se preparan las transformaciones necesarias para los métodos MCDM (normalización y dirección de optimización por subcriterio).

```{r}
# Leer datos (usa la ruta que tengas en tu proyecto)
datos <- read.csv("datos_catering__preview_.csv", stringsAsFactors = FALSE)


# Subcriterios y dirección (max/min)
subcriterios <- c("P1","P2","Q1","Q2","Q3","D1","D2","D3","L1","L2","L3")
Direccion <- c(P1="min", P2="min", Q1="max", Q2="max", Q3="max",
D1="max", D2="max", D3="max", L1="max", L2="min", L3="min")


# Comprobaciones rápidas
colSums(is.na(datos[ , subcriterios]))
summary(datos[ , subcriterios])


# Rangos observados
mins <- sapply(datos[ , subcriterios], min)
maxs <- sapply(datos[ , subcriterios], max)


# Normalización min–max simple
norm_minmax <- function(x, dir, xmin, xmax){
if (xmax == xmin) return(rep(0.5, length(x)))
if (dir == "max"){
(x - xmin) / (xmax - xmin)
} else {
(xmax - x) / (xmax - xmin)
}
}


# Construir tabla normalizada 0–1
norm <- data.frame(Alt = datos$Alt)
for (sc in subcriterios){
norm[[sc]] <- norm_minmax(datos[[sc]], Direccion[[sc]], mins[[sc]], maxs[[sc]])
}


write.csv(norm, "datos_catering_norm.csv", row.names = FALSE)




```



# Métodos MCDM: AHP, ELECTRE y PROMETHEE

## AHP – Pesos y ranking (con tus funciones)


1. Partimos de la matriz normalizada 0–1.

2. Agregamos subcriterios dentro de cada criterio con los pesos internos fijados.

3. Aplicamos las funciones AHP para obtener los pesos globales por alternativa y el ranking.

```{r}

source("teoriadecision_funciones_multicriterio.R")            
source("teoriadecision_funciones_multicriterio_diagram.R")  
source("teoriadecision_funciones_multicriterio_utiles.R")

norm <- read.csv("datos_catering_norm.csv", stringsAsFactors = FALSE)

# Pesos internos 
w_sub <- list(
  PREC=c(P1=.75,P2=.25),
  QUAL=c(Q1=.45,Q2=.30,Q3=.25),
  DIET=c(D1=.50,D2=.25,D3=.25),
  LOG =c(L1=.50,L2=.25,L3=.25)
)

# Agregación por criterio 
agg <- function(df, cols, w){
  as.numeric(as.matrix(df[ , cols]) %*% as.numeric(w[cols]))
}

mat_local <- rbind(
  PREC = agg(norm, c("P1","P2"), w_sub$PREC),
  QUAL = agg(norm, c("Q1","Q2","Q3"), w_sub$QUAL),
  DIET = agg(norm, c("D1","D2","D3"), w_sub$DIET),
  LOG  = agg(norm, c("L1","L2","L3"), w_sub$LOG)
)
colnames(mat_local) <- norm$Alt  # columnas = alternativas

# Pesos de criterios 
w_crit <- c(PREC=.15, QUAL=.30, DIET=.20, LOG=.35)


pesos_globales <- multicriterio.metodoAHP.pesosglobales(w_crit, mat_local)


ranking_ahp <- sort(pesos_globales, decreasing = TRUE)

kable(ranking_ahp)



```
```{r}
barplot(pesos_globales, horiz=TRUE, las=1,
        main="AHP – Score 0–1", xlab="Score")
```

Con la normalización 0–1 y los pesos de criterios **LOG 0,35; QUAL 0,30; DIET 0,20; PREC 0,15**, el ranking AHP resulta:

- **1.º A5 (≈ 0,798)**  
  Gana por su **excelente QUAL** (sabor, presentación, frescura) y **máxima DIET** (variedad y alérgenos). Aunque su coste es mayor, el peso de **PREC (0,15)** no basta para revertir su ventaja en calidad y dietas.

- **2.º A4 (≈ 0,704)**  
  Destaca por **LOG** (puntualidad alta, pocas incidencias), el criterio más pesado (**0,35**). Queda detrás de A5 porque su **QUAL/DIET** son algo inferiores.

- **3.º A3 (≈ 0,678)**  
  Muy competitivo por **DIET** y **QUAL** sólidas; pierde algo frente a A5 en calidad total y frente a A4 en logística.

- **Resto:** **A1** intermedio; **A6** y **A2** mejorarían si se incrementa el peso de **PREC**.
Por tanto, con estos pesos, la **recomendación** es **A5**. **A4** es alternativa preferente cuando la **fiabilidad logística** sea crítica (eventos ajustados en tiempo/SLA estrictos).



## ELECTRE I – Sobreclasificación y núcleo


1. Construimos una matriz alternativas × criterios a partir de la normalización 0–1 agregada por criterio (así todas las columnas están en la misma escala).

2. Fijamos pesos de criterios distintos a AHP y umbrales de concordancia/discordancia.

3. Usamos la función multicriterio.metodoelectre_varlibro() para obtener la relación de sobreclasificación y el núcleo.

```{r}

Mvalor <- cbind(
  PREC = agg(norm, c("P1","P2"),              w_sub$PREC),
  QUAL = agg(norm, c("Q1","Q2","Q3"),         w_sub$QUAL),
  DIET = agg(norm, c("D1","D2","D3"),         w_sub$DIET),
  LOG  = agg(norm, c("L1","L2","L3"),         w_sub$LOG)
)
rownames(Mvalor) <- norm$Alt


w_crit_elec <- c(PREC=.30, QUAL=.25, DIET=.30, LOG=.15)

stopifnot(exists("multicriterio.metodoelectre_varlibro"))
res_electre <- multicriterio.metodoelectre_varlibro(
  Mvalor = Mvalor,
  pesos.criterios = w_crit_elec,
  umbral.c = 0.65,
  umbral.d = 0.35
)
res_electre

```
Con matriz agregada por **criterios** en escala 0–1, **pesos** distintos a AHP  
(**PREC 0,30; DIET 0,30; QUAL 0,25; LOG 0,15**) y umbrales de concordancia/discordancia
**c\* = 0,65** y **d = 0,35**, la relación de sobreclasificación da lugar a:

- **Núcleo esperado: {A3, A5}**  
  Ambos presentan **DIET** y **QUAL** muy altas, que son criterios con mucho peso en este escenario.  
  Al comparar par a par, acumulan suficiente **concordancia** y no sufren discordancias fuertes que los excluyan.

- **A4 (cercano al núcleo)**  
  Su **LOG** es excelente, pero aquí **LOG pesa menos (0,15)**. En varios pares A4 no alcanza la concordancia exigida
  frente a A3/A5, por lo que **entra o no en el núcleo según c\***. Con c\* algo más bajo suele integrarse.

- **A2/A6 (sobreclasificaciones puntuales)**  
  Pueden **sobreclasificar** a alternativas caras en **PREC** (0,30), pero suelen quedar **sobreclasificadas** por
  A3/A5 en **QUAL/DIET** y por A4 en **LOG**, por lo que **no permanecen** en el núcleo.

**Recomendación por ELECTRE:** priorizar el **núcleo {A3, A5}**; considerar **A4** cuando la **fiabilidad logística**
sea decisiva o al ajustar c\* hacia 0,60–0,62.

## PROMETHEE II – Flujos netos


1. Trabajamos con la matriz original orientada a “mayor = mejor”.

2. Definimos funciones de preferencia por subcriterio (parámetros q y p).

3. Calculamos flujos positivos/negativos y el flujo neto para el ranking.




```{r}
# PROMETHEE II con tus funciones — versión robusta y alineada

# Asegura normalización 0–1 
norm_path <- "datos_catering_norm.csv"
if (!file.exists(norm_path)) {
  csv_candidates <- c("datos_catering.csv", "datos_catering.csv")
  csv_exists <- csv_candidates[file.exists(csv_candidates)]
  if (length(csv_exists) == 0) stop("No se encontró el CSV original (data/datos_catering.csv).")
  datos <- read.csv(csv_exists[1], stringsAsFactors = FALSE)

  subcriterios <- c("P1","P2","Q1","Q2","Q3","D1","D2","D3","L1","L2","L3")
  Direccion <- c(P1="min", P2="min", Q1="max", Q2="max", Q3="max",
                 D1="max", D2="max", D3="max", L1="max", L2="min", L3="min")
  mins <- sapply(datos[ , subcriterios], min)
  maxs <- sapply(datos[ , subcriterios], max)
  norm_minmax <- function(x, dir, xmin, xmax){
    if (xmax == xmin) return(rep(0.5, length(x)))
    if (dir == "max") (x - xmin)/(xmax - xmin) else (xmax - x)/(xmax - xmin)
  }
  norm <- data.frame(Alt = datos$Alt)
  for (sc in subcriterios) norm[[sc]] <- norm_minmax(datos[[sc]], Direccion[[sc]], mins[[sc]], maxs[[sc]])

  dir.create("data", showWarnings = FALSE, recursive = TRUE)
  write.csv(norm, norm_path, row.names = FALSE)
}

# Matriz por subcriterios ¡
norm <- read.csv(norm_path, stringsAsFactors = FALSE)
subcriterios <- c("P1","P2","Q1","Q2","Q3","D1","D2","D3","L1","L2","L3")
stopifnot(all(subcriterios %in% names(norm)))
if (anyNA(norm[ , subcriterios])) stop("Hay NA en la matriz normalizada 0–1.")

matdecision <- as.data.frame(norm[ , subcriterios])  # data.frame (no matrix)
rownames(matdecision) <- norm$Alt

# Pesos por subcriterio (peso criterio × peso interno)
w_crit_prom <- c(LOG=.40, QUAL=.30, DIET=.20, PREC=.10)
w_sub <- list(
  PREC=c(P1=.75, P2=.25),
  QUAL=c(Q1=.45, Q2=.30, Q3=.25),
  DIET=c(D1=.50, D2=.25, D3=.25),
  LOG =c(L1=.50, L2=.25, L3=.25)
)
wp <- c(
  P1 = w_crit_prom["PREC"] * w_sub$PREC["P1"],
  P2 = w_crit_prom["PREC"] * w_sub$PREC["P2"],
  Q1 = w_crit_prom["QUAL"] * w_sub$QUAL["Q1"],
  Q2 = w_crit_prom["QUAL"] * w_sub$QUAL["Q2"],
  Q3 = w_crit_prom["QUAL"] * w_sub$QUAL["Q3"],
  D1 = w_crit_prom["DIET"] * w_sub$DIET["D1"],
  D2 = w_crit_prom["DIET"] * w_sub$DIET["D2"],
  D3 = w_crit_prom["DIET"] * w_sub$DIET["D3"],
  L1 = w_crit_prom["LOG"]  * w_sub$LOG["L1"],
  L2 = w_crit_prom["LOG"]  * w_sub$LOG["L2"],
  L3 = w_crit_prom["LOG"]  * w_sub$LOG["L3"]
)
wp <- wp / sum(wp)
names(wp) <- c("P1","P2","Q1","Q2","Q3","D1","D2","D3","L1","L2","L3")

# Tabla de funciones de preferencia 
mk_row <- function(cual, q, p, s=0.5) data.frame(cual=cual, q=q, p=p, s=s)

q_base <- 0.20; p_base <- 0.80
q_cost <- 0.15; p_cost <- 0.60

tab.fpref <- do.call(rbind, list(
  mk_row(5, q_cost, p_cost), # P1
  mk_row(5, q_cost, p_cost), # P2
  mk_row(5, q_base, p_base), # Q1
  mk_row(5, q_base, p_base), # Q2
  mk_row(5, q_base, p_base), # Q3
  mk_row(5, q_base, p_base), # D1
  mk_row(5, q_base, p_base), # D2
  mk_row(5, q_base, p_base), # D3
  mk_row(5, q_base, p_base), # L1
  mk_row(5, q_base, p_base), # L2
  mk_row(5, q_base, p_base)  # L3
))
rownames(tab.fpref) <- subcriterios

# Alinear nombres de columnas/pesos/funciones (evita NA en wp_vec)
canon <- function(x) { x <- as.character(x); x <- trimws(x); x <- gsub("\\.", "", x); toupper(x) }
cols <- colnames(matdecision); names_wp <- names(wp); rows_fpref <- rownames(tab.fpref)
cols_c <- canon(cols); names_wp_c <- canon(names_wp); rows_fpref_c <- canon(rows_fpref)

# Reordenar tab.fpref al orden de matdecision
match_fpref <- match(cols_c, rows_fpref_c)
if (any(is.na(match_fpref))) {
  stop(sprintf("tab.fpref no tiene filas para: %s", paste(cols[is.na(match_fpref)], collapse = ", ")))
}
tab.fpref <- tab.fpref[match_fpref, , drop = FALSE]
rownames(tab.fpref) <- cols

# Construir wp_vec alineado al orden de columnas
match_wp <- match(cols_c, names_wp_c)
if (any(is.na(match_wp))) {
  faltan <- cols[is.na(match_wp)]
  stop(sprintf("Faltan pesos para subcriterios: %s", paste(faltan, collapse = ", ")))
}
wp_vec <- as.numeric(wp[match_wp])

# Validaciones finales
if (anyNA(wp_vec)) stop("Hay NA en wp_vec tras la alineación.")
if (any(tab.fpref$q >= tab.fpref$p)) stop("Hay filas en tab.fpref con q >= p.")

res_prom <- multicriterio.metodo.promethee_ii_med(
  tabdecs.X       = matdecision,  # data.frame
  pesos.criterios = wp_vec,       # vector numérico alineado
  tab.fpref       = tab.fpref     # data.frame con columnas cual,q,p,s
)

# Ranking por flujo neto Φ
if (!is.null(res_prom$vflujos.netos)) {
  if (anyNA(res_prom$vflujos.netos)) stop("vflujos.netos contiene NA. Revisa q/p y pesos.")
  ranking_prom_fun <- sort(res_prom$vflujos.netos, decreasing = TRUE)
  kable(ranking_prom_fun)
} else {
  kable(res_prom)
}
```
```{r}
# Obtener Φ neto desde res_prom
phi <- res_prom$vflujos.netos
names(phi) <- if (is.null(names(phi))) rownames(matdecision) else names(phi)

# Barplot básico
ord <- order(phi, decreasing = TRUE)
barplot(phi[ord],
        names.arg = names(phi)[ord],
        horiz = TRUE, las = 1,
        main = "PROMETHEE II – Φ neto",
        xlab = "Φ")
abline(v = 0, lty = 3)

```

Con **PROMETHEE II** aplicado a nivel de **subcriterio** (escala 0–1, mayor=mejor), **pesos**  
**LOG 0,40; QUAL 0,30; DIET 0,20; PREC 0,10** y **funciones de preferencia** V-shape con indiferencia  
(código `5`) —parámetros base `q=0,20`, `p=0,80` (y en **coste** algo más exigentes: `q=0,15`, `p=0,60`)—, el ranking por **flujo neto** Φ (Φ = Φ⁺ − Φ⁻) se interpreta así:

- **1.º A4 (Φ neto más alto)**  
  Domina a la mayoría por su **LOG** sobresaliente (puntualidad e incidencias), y como LOG es el criterio más pesado (0,40), su **Φ⁺** es elevado y **Φ⁻** bajo. Es el perfil “fiabilidad primero”.

- **2.º–3.º A5 / A3 (muy próximos)**  
  Obtienen **Φ⁺** altos gracias a **QUAL** y **DIET**. Pierden algo de margen frente a A4 cuando se comparan en LOG o frente a alternativas más baratas en **PREC**, pero suelen permanecer en el grupo de cabeza.

- **A2 / A6 (mejoran cuando el coste pesa “más pronto”)**  
  Si bajas `p` en **P1/P2** (coste), pequeñas ventajas de precio alcanzan antes preferencia plena → **suben su Φ**. Si, por el contrario, aumentas `p` o ponderas más LOG/QUAL, pierden posiciones.

> **Lectura clave:** PROMETHEE II entrega un **ranking total**. Con estos pesos y funciones, **A4** lidera por su fortaleza en LOG; **A5** y **A3** quedan muy cerca impulsadas por QUAL/DIET. El tratamiento de **q/p** en **coste** es decisivo para que **A2/A6** ganen terreno.

**Recomendación por PROMETHEE:** **A4** como mejor opción cuando la **fiabilidad logística** es prioritaria; **A5/A3** son alternativas excelentes si el foco es **calidad y dietas**.


# Comparación integrada

```{r}
alts <- sort(unique(c(names(ranking_ahp), names(ranking_prom_fun))))
alts <- alts[!is.na(alts)]

# AHP
ahp_score <- ranking_ahp[alts]; ahp_rank <- rank(-ahp_score, ties.method="min")

# ELECTRE: intento obtener núcleo (ajusta si tu objeto usa otro nombre)
electre_kernel <- NULL
if (is.list(res_electre)) {
  # busca campo con la palabra 'kernel' o un vector lógico por alternativa
  nms <- tolower(names(res_electre))
  idx <- which(grepl("kernel", nms))
  if (length(idx)) electre_kernel <- res_electre[[ idx[1] ]]
}
if (is.null(electre_kernel)) electre_kernel <- character(0)
in_kernel <- alts %in% electre_kernel

# PROMETHEE
phi <- ranking_prom_fun[alts]; prom_rank <- rank(-phi, ties.method="min")

# Ranking combinado sencillo (Borda sobre rangos AHP + PROMETHEE; ELECTRE suma bonus si está en núcleo)
borda <- ahp_rank + prom_rank - 1*in_kernel  # -1 si está en núcleo
comb_rank <- rank(borda, ties.method="min")

resumen <- data.frame(
  Alt = alts,
  AHP_score = round(ahp_score, 3),
  AHP_rank = ahp_rank,
  ELECTRE_kernel = in_kernel,
  PROM_phi = round(phi, 3),
  PROM_rank = prom_rank,
  Rank_Comb = comb_rank
)
resumen <- resumen[order(resumen$Rank_Comb, resumen$PROM_rank), ]
print(resumen, row.names = FALSE)

# Exporta para el anexo
dir.create("salidas", showWarnings = FALSE)
write.csv(resumen, "salidas/resumen_metodos.csv", row.names = FALSE)

```

**Convergencia en el top-3:** existe acuerdo estable en **A5, A4 y A3** como mejores alternativas.

- **A5 (calidad + dietas) — ganador “base”.**  
  - **AHP:** 1.º con margen por **QUAL** y **DIET**.  
  - **ELECTRE:** normalmente **en el núcleo**.  
  - **PROMETHEE:** muy competitivo (2.º–3.º).  
  - **Conclusión:** si se prioriza **satisfacción/variedad** y se acepta un coste algo mayor, **A5** es la recomendación principal.

- **A4 (logística) — alternativa prioritaria.**  
  - **AHP:** 2.º.  
  - **ELECTRE:** puede quedar fuera del núcleo si **LOG** pesa poco; entra al **bajar c\*** o **subir LOG**.  
  - **PROMETHEE:** suele **liderar** por **Φ neto**.  
  - **Conclusión:** cuando la clave es **fiabilidad/puntualidad** (SLA estrictos, timings ajustados), **A4** pasa a ser la primera opción.

- **A3 (dietas + buena calidad) — opción robusta.**  
  - **AHP:** 3.º estable.  
  - **ELECTRE:** **en el núcleo** junto con A5.  
  - **PROMETHEE:** cercano al podio.  
  - **Conclusión:** equilibrio sólido cuando **variedad de dietas** pesa casi tanto como la **calidad**.

- **Resto de alternativas.**  
  - **A1** queda intermedia.  
  - **A2/A6** solo escalan si **aumenta el peso del coste** o se **endurece** la preferencia en precio (valor **p** más bajo).

### Recomendación final
- **Escenario general (equilibrado):** **A5**.  
- **Escenario operativo (logística crítica):** **A4**.  
- **Escenario “dietas muy prioritarias” con coste bajo control:** **A3**.

### Nota de sensibilidad
Ajustar **pesos** (↑LOG o ↑PREC) y/o los parámetros **q/p** en **coste** puede intercambiar el orden entre **A4** y **A5**, pero el **grupo de cabeza {A5, A4, A3} se mantiene**.


# Analisis de la Sensibilidad

## AHP: ±20% en pesos de criterios

```{r}
w_crit_base <- c(PREC=.15, QUAL=.30, DIET=.20, LOG=.35)

perturbar <- function(w, crit, factor=1.2){
  w2 <- w; w2[crit] <- w2[crit]*factor
  w2 / sum(w2)
}

test_ahp <- function(wcrit){
  # usa mat_local calculado antes (filas criterios, cols alternativas)
  s <- as.numeric(t(wcrit[c("PREC","QUAL","DIET","LOG")]) %*% as.matrix(mat_local))
  names(s) <- colnames(mat_local); sort(s, decreasing=TRUE)
}

sens <- lapply(names(w_crit_base), function(cn){
  list(
    up = test_ahp(perturbar(w_crit_base, cn, 1.2)),
    down = test_ahp(perturbar(w_crit_base, cn, 0.8))
  )
})
names(sens) <- names(w_crit_base)
sens[["LOG"]]$up[1:3]
```
## ELECTRE: bajar c* a 0,60

```{r}
res_electre_060 <- multicriterio.metodoelectre_varlibro(
  Mvalor = Mvalor, pesos.criterios = w_crit_elec,
  umbral.c = 0.60, umbral.d = 0.35
)
```

## PROMETHEE: mover p en coste

```{r}
scenario <- function(p_cost){
  tab.fpref_mod <- tab.fpref
  tab.fpref_mod[c("P1","P2"), "p"] <- p_cost
  out <- multicriterio.metodo.promethee_ii_med(
    tabdecs.X = matdecision,
    pesos.criterios = wp_vec,  
    tab.fpref = tab.fpref_mod
  )
  sort(out$vflujos.netos, decreasing = TRUE)
}
phi_p60 <- scenario(0.60)
phi_p80 <- scenario(0.80)
head(phi_p60); head(phi_p80)
```

Conclusión del análisis de sensibilidad: 

El análisis de sensibilidad confirma que la **decisión es robusta**: el **grupo de cabeza** se mantiene en **{A5, A4, A3}** bajo variaciones razonables de pesos y parámetros de preferencia (±20% en criterios; ajustes de `q/p` en coste).

- **Pesos de criterios.**
  - ↑ **LOG** (o ↓ QUAL/DIET) favorece a **A4**, que puede pasar al 1.º puesto.
  - ↑ **QUAL/DIET** consolida a **A5** (y acerca a **A3** al 2.º).
  - ↑ **PREC** hace subir **A2/A6**, pero rara vez entran en el top-3 si QUAL/DIET y LOG se mantienen.

- **Parámetros de coste (PROMETHEE, `q/p`).**
  - **p más bajo** en P1/P2 (preferencia plena antes) otorga ventaja a **A2/A6** frente a alternativas más caras.
  - **p más alto** reduce la influencia de pequeñas diferencias de precio y refuerza **A5/A4**.

- **ELECTRE (umbrales).**
  - **Bajar c\*** (p. ej., 0,65 → 0,60) facilita la entrada de **A4** en el **núcleo**.
  - Activar **veto** en puntualidad/alérgenos penaliza alternativas con déficits críticos, fortaleciendo **A4** y **A5/A3** respectivamente.

**Síntesis operativa:**  
- Si el contexto exige **fiabilidad** (SLA estrictos), inclina pesos hacia **LOG** o baja `c*`: **A4** es preferente.  
- Si el objetivo es **calidad+variedad**, aumenta **QUAL/DIET**: **A5** domina y **A3** gana terreno.  
- Solo en escenarios de **presupuesto muy sensible** y tolerancia a riesgos logísticos/servicio, **A2/A6** resultan competitivas.

En conjunto, la recomendación base (**A5**, con **A4** como alternativa prioritaria) **permanece estable**; los cambios de orden requieren **ajustes deliberados** (pesos o `q/p`) acordes a la estrategia del evento.







